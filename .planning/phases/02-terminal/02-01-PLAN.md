---
phase: 02-terminal
plan: 01
type: execute
wave: 1
depends_on: ["01-01", "01-02"]
files_modified:
  - crates/kobo-daemon/Cargo.toml
  - crates/kobo-daemon/src/process.rs
  - crates/kobo-daemon/src/session.rs
  - crates/kobo-daemon/src/server.rs
  - crates/kobo-daemon/src/lib.rs
  - crates/kobo-core/src/types.rs
  - crates/kobo-core/src/protocol.rs
autonomous: true
---

<objective>
Add PTY process management and session CRUD endpoints to the daemon.

Purpose: The daemon must be able to spawn shell processes in PTYs, manage their lifecycle (create, list, destroy, resize), and stream I/O. This is the backend foundation for terminal panes.

Output: Daemon with /sessions CRUD endpoints, PTY spawning via portable-pty, and I/O streaming via broadcast channels ready for SSE.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Add portable-pty and implement PTY process management</name>
  <files>crates/kobo-daemon/Cargo.toml, crates/kobo-daemon/src/process.rs</files>
  <action>
    Add `portable-pty = "0.9"` to kobo-daemon dependencies.

    Create process.rs with:
    - ManagedProcess struct: holds child process, PTY master (reader + writer), session_id.
    - spawn_shell(pty_size) -> ManagedProcess: Spawn a default shell ($SHELL or /bin/bash) in a PTY with TERM=xterm-256color.
    - ProcessManager struct holding HashMap of SessionId -> ManagedProcess. Methods:
      - create(session_id, pty_size) -> spawn shell process.
      - destroy(session_id) -> kill process, close PTY.
      - write_input(session_id, data) -> write bytes to PTY master.
      - resize(session_id, rows, cols) -> resize the PTY.
      - subscribe_output(session_id) -> tokio broadcast::Receiver for output bytes.
    - For each process, spawn a tokio task that reads from the PTY reader in a loop and broadcasts output via tokio::sync::broadcast channel (capacity 64).
    - Handle process exit detection (child.try_wait).
  </action>
  <verify>cargo check -p kobo-daemon</verify>
  <done>ProcessManager can spawn shells in PTYs, read output, write input, and resize</done>
</task>

<task type="auto">
  <name>Task 2: Implement session manager with full lifecycle</name>
  <files>crates/kobo-daemon/src/session.rs, crates/kobo-core/src/types.rs</files>
  <action>
    Create session.rs with SessionManager struct:
    - create_session(name, model, pty_size) -> Session: Generate UUID, create session record, spawn PTY process via ProcessManager, persist to state.
    - list_sessions() -> Vec<Session>
    - get_session(id) -> Option<Session>
    - destroy_session(id) -> kill process, update status to Terminated, persist.
    - resize_session(id, rows, cols) -> resize PTY.
    - write_input(id, data) -> forward to ProcessManager.
    - subscribe_output(id) -> forward broadcast receiver from ProcessManager.

    SessionManager holds: DaemonState (for persistence), ProcessManager, and sessions HashMap.

    Add to kobo-core types.rs:
    - Add `working_dir: Option<String>` to Session.
    - Add a `CreateSessionRequest` struct with name, model, pty_size fields.
  </action>
  <verify>cargo check -p kobo-daemon</verify>
  <done>SessionManager orchestrates full session lifecycle with PTY process management</done>
</task>

<task type="auto">
  <name>Task 3: Add session CRUD and I/O streaming endpoints to daemon server</name>
  <files>crates/kobo-daemon/src/server.rs, crates/kobo-core/src/protocol.rs</files>
  <action>
    Add endpoints to the axum router:
    - POST /sessions -> create session (JSON body: name, model, pty_size)
    - GET /sessions -> list all sessions
    - GET /sessions/:id -> get session details
    - DELETE /sessions/:id -> destroy session
    - POST /sessions/:id/input -> write input bytes (base64 encoded body)
    - POST /sessions/:id/resize -> resize PTY (JSON body: rows, cols)
    - GET /sessions/:id/output -> SSE stream of terminal output (base64 encoded events)

    The AppState needs to hold a shared SessionManager (Arc<Mutex> or Arc<RwLock>).

    For the SSE output stream:
    - Use axum::response::sse::Sse
    - Subscribe to the session's broadcast channel
    - Emit output as base64-encoded SSE events with event type "output"
    - Include a "started" event when first connecting

    Update kobo-core protocol.rs with request/response types for the new endpoints.

    Add integration tests for session CRUD lifecycle.
  </action>
  <verify>cargo test -p kobo-daemon -- --test-threads=1 2>&1 | tail -30</verify>
  <done>Daemon serves session CRUD + I/O streaming endpoints, integration tests pass</done>
</task>

</tasks>
