---
phase: 02-terminal
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/components/Terminal.tsx
  - src/hooks/useTerminal.ts
  - src/lib/terminal.ts
  - src/lib/ipc.ts
  - src-tauri/src/commands.rs
  - src-tauri/src/bridge.rs
  - src-tauri/src/lib.rs
  - package.json
autonomous: true
---

<objective>
Create xterm.js terminal pane component with PTY streaming through Tauri IPC.

Purpose: Connect the frontend terminal rendering to the daemon's PTY processes. Users should be able to see a working terminal in a single pane with proper I/O streaming, resize handling, and copy/paste.

Output: Working Terminal component backed by xterm.js that streams I/O to/from a daemon session.
</objective>

<tasks>

<task type="auto">
  <name>Task 1: Install xterm.js dependencies and create terminal setup utilities</name>
  <files>package.json, src/lib/terminal.ts</files>
  <action>
    Install xterm.js packages:
    npm install @xterm/xterm @xterm/addon-fit @xterm/addon-webgl @xterm/addon-web-links @xterm/addon-search

    Create src/lib/terminal.ts with:
    - createTerminal(container: HTMLElement) -> { terminal, fitAddon, dispose }
    - Configures Terminal with: fontFamily monospace, fontSize 14, theme (dark matching app colors), cursorBlink true, allowProposedApi true.
    - Loads addons: FitAddon, WebglAddon (with DOM fallback), WebLinksAddon.
    - Sets up ResizeObserver on container for debounced fit (200ms debounce).
    - Returns dispose function that cleans up everything.
  </action>
  <verify>npm run build 2>&1 | tail -10</verify>
  <done>xterm.js installed, terminal setup utility creates configured terminal instances</done>
</task>

<task type="auto">
  <name>Task 2: Create Tauri bridge for session I/O streaming</name>
  <files>src-tauri/src/bridge.rs, src-tauri/src/commands.rs, src-tauri/src/lib.rs, src/lib/ipc.ts</files>
  <action>
    Add Tauri commands for session management:
    - create_session(name, model) -> Session
    - list_sessions() -> Vec<Session>
    - destroy_session(id) -> ()
    - write_input(session_id, data: Vec<u8>) -> ()
    - resize_session(session_id, rows, cols) -> ()

    Create src-tauri/src/bridge.rs:
    - attach_session(session_id, on_output: Channel<Vec<u8>>):
      Connect to daemon SSE endpoint for the session.
      Spawn a task that reads SSE events and forwards output to the Tauri Channel.
      Return when the SSE stream ends or the session is destroyed.

    Update DaemonClient in kobo-core with methods for:
    - create_session, list_sessions, destroy_session, write_input, resize_session
    - stream_output (SSE client that yields output chunks)

    Update src/lib/ipc.ts with typed wrappers for all new commands.
  </action>
  <verify>cargo check -p kobo-tauri && npm run build</verify>
  <done>Tauri bridge streams session I/O, frontend IPC wrappers typed correctly</done>
</task>

<task type="auto">
  <name>Task 3: Create Terminal React component with full I/O pipeline</name>
  <files>src/components/Terminal.tsx, src/hooks/useTerminal.ts</files>
  <action>
    Create src/hooks/useTerminal.ts:
    - useTerminal(sessionId, containerRef) -> { terminal, isConnected }
    - On mount: call attach_session with a Channel callback, create terminal, connect I/O.
    - terminal.onData -> write_input (user keystrokes to daemon).
    - Channel.onmessage -> terminal.write (daemon output to display).
    - terminal.onResize -> resize_session (size changes to daemon).
    - On unmount: clean up Channel listener (delete onmessage), dispose terminal, unlisten.

    Create src/components/Terminal.tsx:
    - Renders a full-size div container.
    - Uses useTerminal hook.
    - Shows loading state while connecting.
    - Imports @xterm/xterm/css/xterm.css.

    Update App.tsx to:
    - After daemon connects, create a session automatically.
    - Render the Terminal component for that session.
    - Show the terminal instead of the status card (keep status in a small bar).
  </action>
  <verify>npm run build</verify>
  <done>Terminal component renders xterm.js connected to daemon PTY with bidirectional I/O</done>
</task>

</tasks>
