---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src-tauri/Cargo.toml
  - src-tauri/tauri.conf.json
  - src-tauri/capabilities/default.json
  - src-tauri/src/lib.rs
  - src-tauri/src/commands.rs
  - src-tauri/src/lifecycle.rs
  - src/main.tsx
  - src/App.tsx
  - package.json
  - vite.config.ts
  - tsconfig.json
  - index.html
autonomous: true

must_haves:
  truths:
    - "User launches the Tauri app and the daemon starts automatically"
    - "User closes the app window and reopens it -- daemon is still running and app reconnects"
    - "User force-kills the daemon, relaunches the app, and it starts a new daemon and reconnects"
    - "App builds on macOS (both Intel and Apple Silicon)"
    - "App builds on Linux (Ubuntu with WebKitGTK)"
  artifacts:
    - path: "src-tauri/tauri.conf.json"
      provides: "Tauri configuration with daemon binary bundling and background throttling disabled"
      contains: "backgroundThrottling"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri app builder with daemon lifecycle setup and command registration"
      min_lines: 30
    - path: "src-tauri/src/commands.rs"
      provides: "Tauri commands as thin proxies to daemon client"
      min_lines: 20
      exports: ["health_check", "list_sessions", "daemon_status"]
    - path: "src-tauri/src/lifecycle.rs"
      provides: "Daemon lifecycle from Tauri's perspective (start, connect, reconnect)"
      min_lines: 40
    - path: "src/App.tsx"
      provides: "Minimal React app showing daemon connection status"
      min_lines: 15
    - path: "package.json"
      provides: "Frontend dependencies including Tauri API and React"
      contains: "@tauri-apps/api"
  key_links:
    - from: "src-tauri/src/lifecycle.rs"
      to: "crates/kobo-core/src/client.rs"
      via: "Tauri lifecycle uses DaemonClient to connect to daemon"
      pattern: "DaemonClient|ensure_daemon_running"
    - from: "src-tauri/src/commands.rs"
      to: "crates/kobo-core/src/client.rs"
      via: "Tauri commands proxy through DaemonClient"
      pattern: "DaemonClient"
    - from: "src/App.tsx"
      to: "src-tauri/src/commands.rs"
      via: "React invokes Tauri commands"
      pattern: "invoke"
---

<objective>
Create the Tauri app shell that connects to the daemon, with the frontend showing daemon connection status.

Purpose: Close the loop on the foundation -- the Tauri app is the user-facing entry point that automatically manages the daemon. This plan validates the full lifecycle: app launch -> daemon start -> connect -> display status. It also sets up the cross-platform build configuration (macOS Intel + ARM, Linux).

Output: Working Tauri v2 app with React frontend that automatically starts/connects to the daemon and displays connection health. Builds on macOS and Linux.
</objective>

<execution_context>
@/Users/justintieu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/justintieu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
@.planning/research/PITFALLS.md

@.planning/phases/01-foundation/01-01-PLAN.md
@.planning/phases/01-foundation/01-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Tauri v2 app with React frontend scaffold</name>
  <files>src-tauri/Cargo.toml, src-tauri/tauri.conf.json, src-tauri/capabilities/default.json, src-tauri/src/lib.rs, package.json, vite.config.ts, tsconfig.json, src/main.tsx, src/App.tsx, index.html</files>
  <action>
    Set up the Tauri v2 app crate and React frontend:

    1. Add src-tauri to the Cargo workspace members in root Cargo.toml.

    2. Create src-tauri/Cargo.toml:
       - Name: kobo-tauri (binary name: kobo)
       - Dependencies: tauri (v2, with features needed for commands), tauri-build (build-dependencies), kobo-core (path dependency), serde, serde_json, tokio, tracing.
       - Use edition 2024.

    3. Create src-tauri/tauri.conf.json:
       - App identifier: com.tensakulabs.kobo
       - Window config: title "Kobo", width 1200, height 800, minWidth 600, minHeight 400.
       - Set backgroundThrottling to "disabled" -- CRITICAL for terminal sessions surviving minimize (Pitfall #4). This requires macOSPrivateApi: true.
       - Set macOSPrivateApi: true in tauri config.
       - Configure externalBin to bundle kobo-daemon binary (path relative to Cargo target).
       - Dev URL pointing to Vite dev server (http://localhost:1420).
       - Build: beforeDevCommand "npm run dev", beforeBuildCommand "npm run build", frontendDist "../dist".

    4. Create src-tauri/capabilities/default.json with minimal permissions:
       - Allow core:default (basic Tauri operations)
       - Allow shell:default for daemon process spawning
       - Restrict to only necessary commands.

    5. Create src-tauri/build.rs with tauri_build::build() call.

    6. Create src-tauri/src/lib.rs:
       - Minimal Tauri app builder.
       - Register commands module.
       - Manage state: DaemonClient wrapped in Mutex (or RwLock + Arc).
       - Setup hook: on app ready, call lifecycle::ensure_daemon() to connect to or start daemon.

    7. Create frontend scaffold:
       - package.json with: react, react-dom, @tauri-apps/api, @tauri-apps/plugin-shell, typescript, @types/react, @types/react-dom, vite, @vitejs/plugin-react, tailwindcss, @tailwindcss/vite.
       - vite.config.ts: React plugin, Tailwind plugin, server on port 1420 (strict port for Tauri dev).
       - tsconfig.json with strict mode, React JSX transform.
       - index.html with root div.
       - src/main.tsx rendering App.
       - src/App.tsx: Minimal component showing "Kobo - Connecting to daemon..." placeholder text.

    Important: Do NOT run npm install yet -- just create the config files. The executor will run npm install as part of verification.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && npm install && cargo check -p kobo-tauri 2>&1 | tail -10</verify>
  <done>Tauri app crate compiles, frontend scaffold exists with all dependencies, tauri.conf.json configured with backgroundThrottling disabled</done>
</task>

<task type="auto">
  <name>Task 2: Implement Tauri-side daemon lifecycle and proxy commands</name>
  <files>src-tauri/src/lifecycle.rs, src-tauri/src/commands.rs, src-tauri/src/lib.rs</files>
  <action>
    Create the Tauri app's daemon management layer:

    1. src-tauri/src/lifecycle.rs:
       - ensure_daemon(app_handle) -> Result<DaemonClient, Error>:
         a. Determine daemon binary path from Tauri's resource dir (for bundled app) or from the Cargo workspace target dir (for development).
         b. Determine socket path: ~/.kobo/kobo.sock
         c. Call DaemonClient::ensure_daemon_running(socket_path, daemon_binary_path) from kobo-core.
         d. On success: return connected client.
         e. On failure: log error, return Err with user-friendly message.

       - For development mode: detect if running via `cargo tauri dev` and use the workspace target/debug/kobo-daemon path.
       - For production: use the bundled binary path from app.path().resource_dir().

    2. src-tauri/src/commands.rs:
       - #[tauri::command] async fn health_check(client: State<DaemonState>) -> Result<DaemonStatus, String>
         Proxy to DaemonClient.health(), map errors to String.
       - #[tauri::command] async fn list_sessions(client: State<DaemonState>) -> Result<Vec<Session>, String>
         Proxy to DaemonClient.list_sessions() (returns empty vec for now since no sessions exist yet).
       - #[tauri::command] async fn daemon_status(client: State<DaemonState>) -> Result<String, String>
         Return "connected" or "disconnected" based on a quick ping.

       Create DaemonState struct wrapping Arc<Mutex<Option<DaemonClient>>> to handle the case where daemon isn't connected yet.

    3. Update src-tauri/src/lib.rs:
       - Register all commands with Tauri app builder.
       - In setup hook: spawn a tokio task that calls ensure_daemon() and stores the client in DaemonState.
       - Emit a "daemon-connected" or "daemon-error" event to the frontend once connection is established or fails.

    Important: All commands are thin proxies. Zero business logic in the Tauri layer. The daemon is the source of truth.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo check -p kobo-tauri 2>&1 | tail -10</verify>
  <done>Tauri commands compile, lifecycle module can find and start daemon, proxy commands bridge to DaemonClient</done>
</task>

<task type="auto">
  <name>Task 3: Create React frontend showing daemon connection status</name>
  <files>src/App.tsx, src/lib/ipc.ts</files>
  <action>
    Build a minimal but functional frontend that proves the full stack works:

    1. src/lib/ipc.ts:
       - Typed wrappers around Tauri invoke():
         export async function healthCheck(): Promise<DaemonStatus>
         export async function daemonStatus(): Promise<string>
         export async function listSessions(): Promise<Session[]>
       - Type definitions matching kobo-core types:
         interface DaemonStatus { pid: number; uptime: number; session_count: number; version: string }
         interface Session { id: string; name: string; model: string; status: string }
       - Listen for "daemon-connected" and "daemon-error" events from Tauri backend.

    2. src/App.tsx:
       - On mount: listen for daemon connection events AND poll daemon_status() every 5 seconds as heartbeat.
       - Display connection state with visual indicator:
         - "Connecting..." (yellow) during initial connection.
         - "Connected" (green) with daemon PID and uptime when healthy.
         - "Disconnected" (red) with error message when daemon is unreachable.
       - Show a simple status panel: "Kobo v0.1.0 | Daemon: [status] | PID: [pid] | Sessions: [count]"
       - Style with Tailwind: dark background (#1a1a2e or similar), centered status card, clean typography.
       - Add a "Reconnect" button that attempts to re-establish daemon connection when in disconnected state.

    Important: This is a proof-of-life UI, not the final interface. It validates the full data flow: React -> Tauri invoke -> DaemonClient -> Unix socket -> Daemon -> response back.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && npm run build 2>&1 | tail -10</verify>
  <done>Frontend builds without errors, shows daemon connection status, typed IPC wrappers match backend types</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds for entire workspace (including src-tauri)
- [ ] `npm run build` succeeds (frontend compiles)
- [ ] `cargo tauri build --debug` produces an app bundle (or at minimum, `cargo tauri dev` launches without errors if full build is too slow)
- [ ] Tauri app starts and shows "Connecting..." status
- [ ] Daemon starts automatically when app launches
- [ ] Health check returns valid daemon status displayed in UI
- [ ] Close app, verify daemon still running (ps aux | grep kobo-daemon)
- [ ] Reopen app, verify it reconnects to existing daemon
- [ ] tauri.conf.json has backgroundThrottling: "disabled"
- [ ] tauri.conf.json has macOSPrivateApi: true
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Full lifecycle validated: app launch -> daemon auto-start -> connect -> display status
- App reconnects to existing daemon after restart
- Force-kill daemon and relaunch app -> new daemon started and connected
- Cross-platform build configuration in place (macOS + Linux targets)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
