---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - crates/kobo-daemon/src/main.rs
  - crates/kobo-daemon/src/lifecycle.rs
  - crates/kobo-daemon/src/pid.rs
  - crates/kobo-daemon/src/state.rs
  - crates/kobo-core/src/types.rs
  - crates/kobo-core/src/client.rs
autonomous: true

must_haves:
  truths:
    - "Daemon writes PID file on startup and removes it on clean shutdown"
    - "Starting a second daemon instance detects existing PID file and refuses to start"
    - "After force-killing daemon (kill -9), next startup cleans up stale PID and socket files"
    - "Daemon can daemonize itself (detach from terminal, run in background)"
    - "Daemon persists session metadata to disk and restores it on restart"
    - "DaemonClient can detect whether daemon is alive or stale"
  artifacts:
    - path: "crates/kobo-daemon/src/lifecycle.rs"
      provides: "Daemon lifecycle management (startup, shutdown, daemonize)"
      min_lines: 60
    - path: "crates/kobo-daemon/src/pid.rs"
      provides: "PID file management (create, validate, cleanup)"
      min_lines: 40
    - path: "crates/kobo-daemon/src/state.rs"
      provides: "Session state persistence (save/load to JSON)"
      min_lines: 30
  key_links:
    - from: "crates/kobo-daemon/src/main.rs"
      to: "crates/kobo-daemon/src/lifecycle.rs"
      via: "main calls lifecycle startup sequence"
      pattern: "lifecycle::"
    - from: "crates/kobo-daemon/src/lifecycle.rs"
      to: "crates/kobo-daemon/src/pid.rs"
      via: "lifecycle uses PID file management"
      pattern: "pid::"
    - from: "crates/kobo-core/src/client.rs"
      to: "crates/kobo-daemon/src/pid.rs"
      via: "client validates PID to detect stale daemon"
      pattern: "pid|PidFile|is_alive"
---

<objective>
Implement daemon lifecycle management: PID file, daemonization, crash recovery, state persistence, and duplicate instance prevention.

Purpose: This is the critical correctness layer. Pitfall #1 (daemon orphaning) and Pitfall #6 (stale socket) are the most common failure modes in daemon architectures. Getting this right ensures users never see stale sockets, duplicate daemons, or lost sessions.

Output: Daemon that reliably starts, backgrounds itself, prevents duplicates, recovers from crashes, and persists session state across restarts.
</objective>

<execution_context>
@/Users/justintieu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/justintieu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md

@.planning/phases/01-foundation/01-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement PID file management and duplicate instance prevention</name>
  <files>crates/kobo-daemon/src/pid.rs, crates/kobo-daemon/src/main.rs</files>
  <action>
    Create pid.rs with a PidFile struct that manages ~/.kobo/kobo.pid:

    PidFile::acquire(path) -> Result<PidFile, PidError>:
    1. Check if PID file exists.
    2. If exists: read PID, check if process is alive via kill(pid, 0) (using nix crate or libc::kill).
       - If alive: return Err(PidError::AlreadyRunning { pid }) -- another daemon instance exists.
       - If dead: log warning "Found stale PID file for dead process {pid}, cleaning up", delete stale PID file AND stale socket file, continue.
    3. Write current process PID to the file.
    4. Return PidFile handle.

    PidFile::drop(): Remove the PID file on clean shutdown. Use the Drop trait.

    PidFile::is_process_alive(pid) -> bool: Static method using kill(pid, 0) on Unix.

    PidError enum: AlreadyRunning { pid: u32 }, IoError(std::io::Error), InvalidPidFile(String).

    Integrate into main.rs: Call PidFile::acquire() early in startup, before binding socket. Store the PidFile in the daemon's state so Drop runs on shutdown.

    Important: The PID file path should be derived from the socket path (same directory). Default: ~/.kobo/kobo.pid.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo test -p kobo-daemon -- pid --test-threads=1 2>&1 | tail -20</verify>
  <done>PID file created on startup, blocks duplicate instances, stale PID detection works, file removed on clean shutdown</done>
</task>

<task type="auto">
  <name>Task 2: Implement daemon lifecycle (daemonize, signal handling, graceful shutdown)</name>
  <files>crates/kobo-daemon/src/lifecycle.rs, crates/kobo-daemon/src/main.rs</files>
  <action>
    Create lifecycle.rs with the full daemon startup/shutdown sequence:

    DaemonLifecycle::start(config) -> Result<(), Error>:
    1. Ensure ~/.kobo/ directory exists with 0700 permissions.
    2. Acquire PID file (from Task 1).
    3. If --daemonize flag: perform double-fork daemonization:
       - First fork: parent exits, child continues.
       - setsid() to create new session.
       - Second fork: first child exits, grandchild continues.
       - Redirect stdin/stdout/stderr to /dev/null (or log file).
       - Update PID file with new (grandchild) PID.
       Use the `daemonize` crate or `nix` fork/setsid directly. Prefer the `daemonize` crate for simplicity.
    4. If --foreground flag (default for development): skip daemonization, run in foreground.
    5. Set up signal handlers:
       - SIGTERM -> initiate graceful shutdown.
       - SIGINT -> initiate graceful shutdown (for Ctrl+C in foreground mode).
       - SIGHUP -> reload configuration (future, just log for now).
       Use tokio::signal::unix::signal() for async signal handling.
    6. Start the axum server (from Plan 01).

    GracefulShutdown sequence:
    1. Log "Shutdown initiated".
    2. Stop accepting new connections.
    3. Wait for in-flight requests to complete (with 5-second timeout).
    4. Persist session state to disk (see Task 3).
    5. PID file removed (via Drop).
    6. Socket file removed (explicit cleanup + Drop guard).
    7. Exit with code 0.

    Create a SocketGuard struct (Drop trait) that removes the socket file. This ensures cleanup even on panic.

    Update main.rs to use the lifecycle module as the orchestrator for the startup sequence. CLI args: --daemonize, --foreground (default), --socket-path <path>, --log-level <level>.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo build -p kobo-daemon && echo "Build OK"</verify>
  <done>Daemon can run in foreground or daemonize, handles SIGTERM/SIGINT gracefully, cleans up PID and socket files on shutdown, SocketGuard ensures cleanup on panic</done>
</task>

<task type="auto">
  <name>Task 3: Implement state persistence and crash recovery tests</name>
  <files>crates/kobo-daemon/src/state.rs, crates/kobo-core/src/client.rs, crates/kobo-daemon/tests/lifecycle.rs</files>
  <action>
    Create state.rs with DaemonState struct:
    - sessions: HashMap of SessionId -> Session (from kobo-core types).
    - save(path) -> Result: Serialize to JSON and write to ~/.kobo/state.json atomically (write to temp file, then rename -- prevents corruption on crash during write).
    - load(path) -> Result<DaemonState>: Read and deserialize from JSON. If file missing or corrupt, return default empty state with warning log.

    Update DaemonClient in kobo-core/client.rs:
    - Add ensure_daemon_running(socket_path, daemon_binary_path) -> Result<DaemonClient>:
      1. Try to connect to socket.
      2. If success: return connected client.
      3. If connection fails: check PID file.
         a. If PID alive but socket dead: something is wrong, log error, return Err.
         b. If PID dead or no PID: clean up stale files, spawn daemon binary with --daemonize flag.
         c. Wait for socket to appear (poll every 100ms, timeout 5 seconds).
         d. Connect and return client.
    - Add is_daemon_alive(socket_path) -> bool: Quick liveness check (connect + /ping).

    Create comprehensive lifecycle integration tests in tests/lifecycle.rs:
    1. test_pid_prevents_duplicate: Start daemon, try to start second, verify it fails with AlreadyRunning.
    2. test_stale_pid_cleanup: Write a PID file with a dead PID, start daemon, verify it cleans up and starts successfully.
    3. test_stale_socket_cleanup: Create a dummy socket file, start daemon, verify it cleans up and binds successfully. (This may overlap with Plan 01's test -- make this one more specific about the PID+socket combo.)
    4. test_graceful_shutdown_cleans_up: Start daemon, send SIGTERM, verify PID file and socket file are both removed.
    5. test_state_persistence: Create a DaemonState with sessions, save to disk, load it back, verify equality.
    6. test_atomic_state_write: Verify that state write uses temp file + rename (check implementation, not just behavior).
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo test -p kobo-daemon -- --test-threads=1 2>&1 | tail -30</verify>
  <done>State persistence works with atomic writes, crash recovery cleans up stale files, all lifecycle tests pass, DaemonClient can detect and start daemon</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build -p kobo-daemon` succeeds
- [ ] `cargo test -p kobo-daemon -- --test-threads=1` passes all tests
- [ ] PID file prevents duplicate daemon instances
- [ ] Stale PID file (dead process) is detected and cleaned up
- [ ] Stale socket file is detected and cleaned up
- [ ] SIGTERM triggers graceful shutdown with full cleanup
- [ ] State persistence saves and loads correctly
- [ ] DaemonClient.ensure_daemon_running() can start and connect to daemon
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- The daemon lifecycle is robust: start, persist, recover, prevent duplicates
- No stale files left after any shutdown scenario
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
