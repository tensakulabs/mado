---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - crates/kobo-core/Cargo.toml
  - crates/kobo-core/src/lib.rs
  - crates/kobo-core/src/types.rs
  - crates/kobo-core/src/protocol.rs
  - crates/kobo-core/src/client.rs
  - crates/kobo-daemon/Cargo.toml
  - crates/kobo-daemon/src/main.rs
  - crates/kobo-daemon/src/server.rs
autonomous: true

must_haves:
  truths:
    - "Cargo workspace compiles with `cargo build` producing kobo-daemon binary"
    - "kobo-daemon starts and listens on a Unix domain socket"
    - "A client can connect to the socket and receive a health check response"
    - "Workspace compiles on both macOS and Linux targets"
  artifacts:
    - path: "Cargo.toml"
      provides: "Workspace root with all crate members"
      contains: "workspace"
    - path: "crates/kobo-core/src/types.rs"
      provides: "Shared types (SessionId, Session, DaemonStatus)"
      min_lines: 30
    - path: "crates/kobo-core/src/protocol.rs"
      provides: "IPC request/response message types"
      min_lines: 20
    - path: "crates/kobo-core/src/client.rs"
      provides: "DaemonClient that connects to Unix socket"
      min_lines: 30
    - path: "crates/kobo-daemon/src/main.rs"
      provides: "Daemon entry point with CLI args and signal handling"
      min_lines: 40
    - path: "crates/kobo-daemon/src/server.rs"
      provides: "Axum router over Unix domain socket with health endpoint"
      min_lines: 40
  key_links:
    - from: "crates/kobo-daemon/src/server.rs"
      to: "crates/kobo-core/src/protocol.rs"
      via: "uses shared protocol types for request/response"
      pattern: "use kobo_core::protocol"
    - from: "crates/kobo-core/src/client.rs"
      to: "crates/kobo-daemon/src/server.rs"
      via: "client connects to daemon's Unix socket"
      pattern: "UnixStream"
---

<objective>
Scaffold the Rust workspace with kobo-core types and a minimal kobo-daemon that listens on a Unix domain socket.

Purpose: Establish the foundational crate structure and prove the core IPC pattern works -- daemon binds a Unix socket, serves routes via axum, and a client can connect and communicate. This is the skeleton everything else builds on.

Output: Cargo workspace with kobo-core (types, protocol, client) and kobo-daemon (main, server with health endpoint) that compiles and runs.
</objective>

<execution_context>
@/Users/justintieu/.claude/get-shit-done/workflows/execute-plan.md
@/Users/justintieu/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/ARCHITECTURE.md
@.planning/research/STACK.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cargo workspace and kobo-core crate with shared types</name>
  <files>Cargo.toml, crates/kobo-core/Cargo.toml, crates/kobo-core/src/lib.rs, crates/kobo-core/src/types.rs, crates/kobo-core/src/protocol.rs, crates/kobo-core/src/client.rs</files>
  <action>
    Create the root Cargo.toml as a workspace with members: crates/kobo-core, crates/kobo-daemon. Use Rust Edition 2024.

    Define workspace.dependencies for shared deps: serde (with derive), serde_json, tokio (full features), thiserror, tracing, tracing-subscriber.

    Create kobo-core crate with:
    - types.rs: SessionId (newtype over String), Session struct (id, name, model, status, created_at, updated_at), SessionStatus enum (Active, Idle, Suspended, Terminated), DaemonStatus struct (pid, uptime, session_count, version), PtySize struct (rows, cols). All types derive Serialize, Deserialize, Debug, Clone.
    - protocol.rs: DaemonRequest enum (Health, ListSessions, CreateSession{name, model}, DestroySession{id}, Ping) and DaemonResponse enum (Health{status}, Sessions{list}, SessionCreated{session}, Error{message}, Pong). All derive Serialize, Deserialize, Debug.
    - client.rs: DaemonClient struct holding socket_path (PathBuf). Implement connect() that creates a hyper client over Unix socket (or use reqwest with unix-socket feature, or raw HTTP over UnixStream). For now, implement a minimal connect() that verifies the socket exists and is connectable, and a health() method that sends GET /health and returns DaemonStatus. Use tokio UnixStream.
    - lib.rs: Re-export all modules.

    Important: Keep the client simple for now -- it just needs to prove connectivity. Full HTTP client implementation can be refined in Plan 02 when the daemon has real endpoints.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo check -p kobo-core</verify>
  <done>kobo-core compiles with no errors, all types and protocol messages defined, client struct exists with connect and health methods</done>
</task>

<task type="auto">
  <name>Task 2: Create kobo-daemon crate with axum server over Unix socket</name>
  <files>crates/kobo-daemon/Cargo.toml, crates/kobo-daemon/src/main.rs, crates/kobo-daemon/src/server.rs</files>
  <action>
    Create kobo-daemon as a binary crate depending on kobo-core, axum, tokio, hyper, hyper-util, tower, serde, serde_json, tracing, tracing-subscriber.

    server.rs: Create an axum Router with:
    - GET /health -> returns JSON DaemonResponse::Health with pid, uptime (seconds since start), session_count: 0, version from Cargo.toml.
    - GET /ping -> returns DaemonResponse::Pong (for liveness checks).

    Bind the router to a Unix domain socket at a configurable path (default: ~/.kobo/kobo.sock). Use tokio::net::UnixListener and axum::serve(). Before binding, remove any existing socket file at that path (stale socket cleanup -- if the file exists, try to connect first; if connection fails, delete it). After binding, set socket permissions to 0600 using std::fs::set_permissions with mode 0o600.

    Ensure ~/.kobo/ directory exists (create with 0700 permissions if not).

    main.rs: Parse minimal CLI args (--socket-path override, --foreground flag). Set up tracing subscriber for logging. Call server::start_server(). Set up signal handling for SIGTERM and SIGINT that triggers graceful shutdown (stop accepting connections, remove socket file, exit).

    Important: Do NOT implement daemonization (double-fork) in this plan -- that comes in Plan 02. This plan runs the daemon in the foreground for testing.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo build -p kobo-daemon 2>&1 | tail -5</verify>
  <done>kobo-daemon binary compiles, produces executable in target/debug/kobo-daemon</done>
</task>

<task type="auto">
  <name>Task 3: Integration test -- daemon starts and responds to health check</name>
  <files>crates/kobo-daemon/tests/health_check.rs</files>
  <action>
    Create an integration test that:
    1. Starts kobo-daemon on a temporary Unix socket path (use tempdir to avoid conflicts).
    2. Waits for the socket to appear (poll with timeout).
    3. Connects to the socket and sends an HTTP GET /health request.
    4. Asserts the response is 200 OK and contains valid DaemonStatus JSON with a pid field.
    5. Sends GET /ping and asserts Pong response.
    6. Shuts down the daemon (send SIGTERM or use a shutdown channel).
    7. Verifies the socket file is cleaned up after shutdown.

    Use tokio::net::UnixStream for the raw connection if needed, or use hyper with unix connector. The test must be self-contained and not interfere with any running daemon.

    Also add a basic test that verifies stale socket cleanup: create a dummy file at the socket path, then start the daemon -- it should detect the stale socket, remove it, and bind successfully.
  </action>
  <verify>cd /Users/justintieu/tensakulabs/kobo && cargo test -p kobo-daemon -- --test-threads=1 2>&1 | tail -20</verify>
  <done>Integration tests pass: daemon starts, responds to health check, cleans up socket on shutdown, handles stale socket file</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `cargo build` succeeds for the entire workspace
- [ ] `cargo test -p kobo-daemon -- --test-threads=1` passes all tests
- [ ] kobo-daemon binary exists in target/debug/
- [ ] Running the daemon manually creates socket at specified path
- [ ] Socket file has 0600 permissions
- [ ] Health endpoint returns valid JSON response
- [ ] Daemon removes socket file on clean shutdown (SIGTERM)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Workspace compiles cleanly with no warnings on both library and binary crates
- Integration tests demonstrate working IPC over Unix socket
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
